-- =====================================================
-- STORED PROCEDURES - BUSINESS LOGIC (FIXED FOR MARIADB)
-- =====================================================

DELIMITER $$

-- 1. QUẢN LÝ ĐƠN HÀNG

-- Tạo đơn hàng mới và tính tổng tiền
DROP PROCEDURE IF EXISTS sp_CreateOrder$$
CREATE PROCEDURE sp_CreateOrder(
    IN p_customer_id INT,
    IN p_source TINYINT,
    IN p_address VARCHAR(255),
    IN p_note TEXT,
    IN p_user_id INT,
    IN p_order_details JSON,
    OUT p_order_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_product_id INT;
    DECLARE v_quantity DECIMAL(10,2);
    DECLARE v_unit_price DECIMAL(10,2);
    DECLARE v_total DECIMAL(10,2) DEFAULT 0;
    DECLARE v_idx INT DEFAULT 0;
    DECLARE v_count INT;
    DECLARE v_json_array JSON;
    DECLARE v_product_exists INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error creating order';
        SET p_order_id = 0;
    END;
    
    SET p_order_id = 0;
    SET p_message = '';
    
    START TRANSACTION;
    
    -- Tạo đơn hàng
    INSERT INTO orders (customer_id, source, address, note, user_id, status, payment_status)
    VALUES (p_customer_id, p_source, p_address, p_note, p_user_id, 0, 0);
    
    SET p_order_id = LAST_INSERT_ID();
    
    -- Xử lý từng sản phẩm trong JSON
    SET v_json_array = p_order_details;
    SET v_count = JSON_LENGTH(v_json_array);
    
    WHILE v_idx < v_count DO
        SET v_product_id = JSON_UNQUOTE(JSON_EXTRACT(v_json_array, CONCAT('$[', v_idx, '].product_id'))) + 0;
        SET v_quantity = JSON_UNQUOTE(JSON_EXTRACT(v_json_array, CONCAT('$[', v_idx, '].quantity'))) + 0;
        SET v_unit_price = JSON_UNQUOTE(JSON_EXTRACT(v_json_array, CONCAT('$[', v_idx, '].unit_price'))) + 0;
        
        -- Kiểm tra sản phẩm tồn tại và active
        SELECT COUNT(*) INTO v_product_exists 
        FROM products 
        WHERE product_id = v_product_id AND is_active = 1;
        
        IF v_product_exists = 0 THEN
            SET p_message = CONCAT('Product ID ', v_product_id, ' not found or inactive');
            ROLLBACK;
            SET p_order_id = 0;
            LEAVE proc_label;
        END IF;
        
        -- Thêm chi tiết đơn
        INSERT INTO orderdetails (order_id, product_id, quantity, unit_price)
        VALUES (p_order_id, v_product_id, v_quantity, v_unit_price);
        
        SET v_total = v_total + (v_quantity * v_unit_price);
        SET v_idx = v_idx + 1;
    END WHILE;
    
    COMMIT;
    SET p_message = CONCAT('Order created successfully: #', p_order_id);
END$$

-- Cập nhật trạng thái đơn hàng và xử lý kho
DROP PROCEDURE IF EXISTS sp_UpdateOrderStatus$$
CREATE PROCEDURE sp_UpdateOrderStatus(
    IN p_order_id INT,
    IN p_new_status TINYINT,
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_old_status TINYINT DEFAULT NULL;
    DECLARE v_product_id INT;
    DECLARE v_quantity DECIMAL(10,2);
    DECLARE done INT DEFAULT FALSE;
    
    DECLARE cur CURSOR FOR 
        SELECT product_id, quantity FROM orderdetails WHERE order_id = p_order_id;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error updating order status';
    END;
    
    START TRANSACTION;
    
    -- Lấy trạng thái cũ
    SELECT status INTO v_old_status FROM orders WHERE order_id = p_order_id;
    
    IF v_old_status IS NULL THEN
        SET p_message = 'Order not found';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- Nếu chuyển sang PROCESSING (2) -> trừ kho
    IF p_new_status = 2 AND v_old_status != 2 THEN
        OPEN cur;
        read_loop: LOOP
            FETCH cur INTO v_product_id, v_quantity;
            IF done THEN
                LEAVE read_loop;
            END IF;
            
            INSERT INTO stockout (ref_type, ref_id, quantity, purpose, notes, created_by)
            VALUES (0, v_product_id, v_quantity, 0, CONCAT('Order #', p_order_id), p_user_id);
        END LOOP read_loop;
        CLOSE cur;
    END IF;
    
    -- Cập nhật trạng thái
    UPDATE orders SET status = p_new_status WHERE order_id = p_order_id;
    
    COMMIT;
    SET p_message = 'Order status updated successfully';
END$$

-- 2. QUẢN LÝ KHO

-- Nhập kho sản phẩm
DROP PROCEDURE IF EXISTS sp_StockIn_Product$$
CREATE PROCEDURE sp_StockIn_Product(
    IN p_product_id INT,
    IN p_quantity DECIMAL(10,2),
    IN p_batch_no VARCHAR(100),
    IN p_expiry_date DATE,
    IN p_unit_price DECIMAL(10,2),
    IN p_supplier_id INT,
    IN p_notes TEXT,
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_product_exists INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error during stock in';
    END;
    
    START TRANSACTION;
    
    -- Kiểm tra sản phẩm tồn tại
    SELECT COUNT(*) INTO v_product_exists FROM products WHERE product_id = p_product_id;
    
    IF v_product_exists = 0 THEN
        SET p_message = 'Product not found';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- Ghi nhận nhập kho
    INSERT INTO stockin (batch_no, ref_type, ref_id, quantity, unit_price, 
                         notes, supplier_id, expiry_date, created_by)
    VALUES (p_batch_no, 0, p_product_id, p_quantity, p_unit_price,
            p_notes, p_supplier_id, p_expiry_date, p_user_id);
    
    COMMIT;
    SET p_message = 'Stock in successful';
END$$

-- Xuất kho sản phẩm
DROP PROCEDURE IF EXISTS sp_StockOut_Product$$
CREATE PROCEDURE sp_StockOut_Product(
    IN p_product_id INT,
    IN p_quantity DECIMAL(10,2),
    IN p_purpose TINYINT,
    IN p_notes TEXT,
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_total_stock DECIMAL(10,2) DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error during stock out';
    END;
    
    START TRANSACTION;
    
    -- Kiểm tra tồn kho
    SELECT COALESCE(SUM(quantity), 0) INTO v_total_stock
    FROM inventories
    WHERE product_id = p_product_id;
    
    IF v_total_stock < p_quantity THEN
        SET p_message = CONCAT('Insufficient inventory. Available: ', v_total_stock, ', Required: ', p_quantity);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- Ghi nhận xuất kho
    INSERT INTO stockout (ref_type, ref_id, quantity, purpose, notes, created_by)
    VALUES (0, p_product_id, p_quantity, p_purpose, p_notes, p_user_id);
    
    COMMIT;
    SET p_message = 'Stock out successful';
END$$

-- Cảnh báo sản phẩm sắp hết
DROP PROCEDURE IF EXISTS sp_GetLowStockAlert$$
CREATE PROCEDURE sp_GetLowStockAlert()
BEGIN
    SELECT 
        p.product_id,
        p.sku,
        p.name,
        p.unit,
        COALESCE(SUM(i.quantity), 0) AS current_stock,
        p.min_stock_level,
        p.min_stock_level - COALESCE(SUM(i.quantity), 0) AS shortage
    FROM products p
    LEFT JOIN inventories i ON p.product_id = i.product_id
    WHERE p.is_active = 1
    GROUP BY p.product_id, p.sku, p.name, p.unit, p.min_stock_level
    HAVING current_stock < p.min_stock_level
    ORDER BY shortage DESC;
END$$

-- Cảnh báo sản phẩm gần hết hạn
DROP PROCEDURE IF EXISTS sp_GetExpiryAlert$$
CREATE PROCEDURE sp_GetExpiryAlert(
    IN p_days_threshold INT
)
BEGIN
    SELECT 
        i.inventory_id,
        i.batch_no,
        p.name AS product_name,
        i.quantity,
        i.expiry_date,
        DATEDIFF(i.expiry_date, CURDATE()) AS days_to_expiry
    FROM inventories i
    JOIN products p ON i.product_id = p.product_id
    WHERE i.expiry_date IS NOT NULL
        AND i.quantity > 0
        AND DATEDIFF(i.expiry_date, CURDATE()) <= p_days_threshold
        AND DATEDIFF(i.expiry_date, CURDATE()) >= 0
    ORDER BY i.expiry_date ASC;
END$$

-- 3. QUẢN LÝ BAO BÌ

-- Phát bao bì cho khách hàng
DROP PROCEDURE IF EXISTS sp_IssuePackaging$$
CREATE PROCEDURE sp_IssuePackaging(
    IN p_packaging_id INT,
    IN p_customer_id INT,
    IN p_quantity INT,
    IN p_ownership_type TINYINT,
    IN p_deposit_price DECIMAL(10,2),
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_available INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error issuing packaging';
    END;
    
    START TRANSACTION;
    
    -- Kiểm tra tồn kho bao bì mới
    SELECT COALESCE(qty_new, 0) INTO v_available
    FROM packaginginventories
    WHERE packaging_id = p_packaging_id;
    
    IF v_available < p_quantity THEN
        SET p_message = CONCAT('Insufficient packaging inventory. Available: ', v_available, ', Required: ', p_quantity);
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- Ghi nhận giao dịch
    INSERT INTO packagingtransactions 
        (packaging_id, customer_id, user_id, type, ownership_type, 
         quantity, deposit_price, notes)
    VALUES 
        (p_packaging_id, p_customer_id, p_user_id, 0, p_ownership_type,
         p_quantity, p_deposit_price, CONCAT('Issued ', p_quantity, ' units'));
    
    COMMIT;
    SET p_message = 'Packaging issued successfully';
END$$

-- Thu hồi bao bì từ khách hàng
DROP PROCEDURE IF EXISTS sp_ReturnPackaging$$
CREATE PROCEDURE sp_ReturnPackaging(
    IN p_packaging_id INT,
    IN p_customer_id INT,
    IN p_quantity INT,
    IN p_condition TINYINT,
    IN p_refund_amount DECIMAL(10,2),
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error returning packaging';
    END;
    
    START TRANSACTION;
    
    -- Ghi nhận giao dịch
    INSERT INTO packagingtransactions 
        (packaging_id, customer_id, user_id, type, quantity, 
         refund_amount, notes)
    VALUES 
        (p_packaging_id, p_customer_id, p_user_id, 1, p_quantity,
         p_refund_amount, CONCAT('Returned - condition: ', p_condition));
    
    -- Cập nhật tồn kho theo điều kiện
    IF p_condition = 0 THEN
        UPDATE packaginginventories
        SET qty_returned = qty_returned + p_quantity,
            last_updated = NOW()
        WHERE packaging_id = p_packaging_id;
    ELSEIF p_condition = 1 THEN
        UPDATE packaginginventories
        SET qty_need_cleaning = qty_need_cleaning + p_quantity,
            last_updated = NOW()
        WHERE packaging_id = p_packaging_id;
    ELSEIF p_condition = 2 THEN
        UPDATE packaginginventories
        SET qty_damaged = qty_damaged + p_quantity,
            last_updated = NOW()
        WHERE packaging_id = p_packaging_id;
    END IF;
    
    COMMIT;
    SET p_message = 'Packaging returned successfully';
END$$

-- Xử lý bao bì sau vệ sinh
DROP PROCEDURE IF EXISTS sp_ProcessCleanedPackaging$$
CREATE PROCEDURE sp_ProcessCleanedPackaging(
    IN p_packaging_id INT,
    IN p_quantity_cleaned INT,
    IN p_quantity_damaged INT,
    IN p_user_id INT,
    OUT p_message VARCHAR(255)
)
proc_label: BEGIN
    DECLARE v_available INT DEFAULT 0;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_message = 'Error processing cleaned packaging';
    END;
    
    START TRANSACTION;
    
    SELECT COALESCE(qty_need_cleaning, 0) INTO v_available
    FROM packaginginventories
    WHERE packaging_id = p_packaging_id;
    
    IF v_available < (p_quantity_cleaned + p_quantity_damaged) THEN
        SET p_message = CONCAT('Invalid quantity. Available: ', v_available, ', Required: ', (p_quantity_cleaned + p_quantity_damaged));
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    UPDATE packaginginventories
    SET qty_need_cleaning = qty_need_cleaning - (p_quantity_cleaned + p_quantity_damaged),
        qty_cleaned = qty_cleaned + p_quantity_cleaned,
        qty_damaged = qty_damaged + p_quantity_damaged,
        last_updated = NOW()
    WHERE packaging_id = p_packaging_id;
    
    INSERT INTO cleaningschedules (cleaning_type, cleaning_date, status, 
                                    notes, cleaning_by)
    VALUES (1, NOW(), 1,
            CONCAT('Cleaned: ', p_quantity_cleaned, ', Damaged: ', p_quantity_damaged),
            p_user_id);
    
    COMMIT;
    SET p_message = 'Cleaned packaging processed';
END$$

-- 4. TÍNH ĐIỂM THƯỞNG KHÁCH HÀNG

DROP PROCEDURE IF EXISTS sp_CalculateCustomerPoints$$
CREATE PROCEDURE sp_CalculateCustomerPoints(
    IN p_customer_id INT,
    IN p_order_amount DECIMAL(10,2),
    OUT p_points_earned INT,
    OUT p_message VARCHAR(255)
)
BEGIN
    DECLARE v_current_points INT DEFAULT 0;
    DECLARE v_current_rank TINYINT DEFAULT 0;
    DECLARE v_point_rate DECIMAL(5,2) DEFAULT 1.0;
    DECLARE v_rank_msg VARCHAR(255);
    
    -- Lấy thông tin khách hàng
    SELECT COALESCE(total_point, 0), COALESCE(`rank`, 0) 
    INTO v_current_points, v_current_rank
    FROM customers
    WHERE customer_id = p_customer_id;
    
    -- Quy tắc tính điểm theo rank
    CASE v_current_rank
        WHEN 0 THEN SET v_point_rate = 1.0;
        WHEN 1 THEN SET v_point_rate = 1.2;
        WHEN 2 THEN SET v_point_rate = 1.5;
        WHEN 3 THEN SET v_point_rate = 2.0;
        ELSE SET v_point_rate = 1.0;
    END CASE;
    
    -- Tính điểm
    SET p_points_earned = FLOOR(p_order_amount / 10000 * v_point_rate);
    
    -- Cập nhật điểm
    UPDATE customers
    SET total_point = total_point + p_points_earned
    WHERE customer_id = p_customer_id;
    
    -- Kiểm tra nâng hạng
    CALL sp_UpdateCustomerRank(p_customer_id, v_rank_msg);
    
    SET p_message = CONCAT('Earned ', p_points_earned, ' points');
END$$

-- Cập nhật hạng khách hàng
DROP PROCEDURE IF EXISTS sp_UpdateCustomerRank$$
CREATE PROCEDURE sp_UpdateCustomerRank(
    IN p_customer_id INT,
    OUT p_message VARCHAR(255)
)
BEGIN
    DECLARE v_total_points INT DEFAULT 0;
    DECLARE v_new_rank TINYINT DEFAULT 0;
    DECLARE v_old_rank TINYINT DEFAULT 0;
    
    SELECT COALESCE(total_point, 0), COALESCE(`rank`, 0) 
    INTO v_total_points, v_old_rank
    FROM customers
    WHERE customer_id = p_customer_id;
    
    -- Quy tắc xếp hạng
    IF v_total_points >= 5000 THEN
        SET v_new_rank = 3;
    ELSEIF v_total_points >= 2000 THEN
        SET v_new_rank = 2;
    ELSEIF v_total_points >= 500 THEN
        SET v_new_rank = 1;
    ELSE
        SET v_new_rank = 0;
    END IF;
    
    -- Cập nhật nếu có thay đổi
    IF v_new_rank != v_old_rank THEN
        UPDATE customers
        SET `rank` = v_new_rank
        WHERE customer_id = p_customer_id;
        
        SET p_message = CONCAT('Rank updated: ', v_old_rank, ' -> ', v_new_rank);
    ELSE
        SET p_message = 'Rank unchanged';
    END IF;
END$$

DELIMITER ;

/*
=======================================================
HƯỚNG DẪN SỬ DỤNG STORED PROCEDURES
=======================================================

1. TẠO ĐƠN HÀNG:
   CALL sp_CreateOrder(
       1,                          -- customer_id
       3,                          -- source: 0=GOOGLEFORM, 1=EXCEL, 2=EMAIL, 3=MANUAL
       '123 Nguyễn Văn A, Q1',     -- address
       'Giao buổi sáng',           -- note
       1,                          -- user_id
       '[{"product_id":1,"quantity":10,"unit_price":50000},{"product_id":2,"quantity":5,"unit_price":30000}]',
       @order_id,
       @message
   );
   SELECT @order_id, @message;

2. CẬP NHẬT TRẠNG THÁI ĐƠN HÀNG:
   -- Status: 0=DRAFT, 1=CONFIRMED, 2=PROCESSING, 3=READY, 4=SHIPPED, 5=COMPLETED, 6=CANCELLED
   CALL sp_UpdateOrderStatus(1, 2, 1, @message);
   SELECT @message;

3. NHẬP KHO SẢN PHẨM:
   CALL sp_StockIn_Product(
       1,                          -- product_id
       100.00,                     -- quantity
       'BATCH-2024-001',           -- batch_no
       '2025-12-31',               -- expiry_date
       45000.00,                   -- unit_price
       1,                          -- supplier_id
       'Nhập hàng tháng 1',        -- notes
       1,                          -- user_id
       @message
   );
   SELECT @message;

4. XUẤT KHO SẢN PHẨM:
   -- Purpose: 0=SALE, 1=DAMAGE, 2=TRANSFER
   CALL sp_StockOut_Product(1, 10.00, 0, 'Xuất bán', 1, @message);
   SELECT @message;

5. CẢNH BÁO TỒN KHO THẤP:
   CALL sp_GetLowStockAlert();

6. CẢNH BÁO SẢN PHẨM SẮP HẾT HẠN:
   CALL sp_GetExpiryAlert(30);  -- Sản phẩm hết hạn trong 30 ngày

7. PHÁT BAO BÌ CHO KHÁCH:
   -- Ownership: 0=DEPOSIT (đặt cọc), 1=SOLD (bán)
   CALL sp_IssuePackaging(1, 1, 10, 0, 50000.00, 1, @message);
   SELECT @message;

8. THU HỒI BAO BÌ:
   -- Condition: 0=clean, 1=need_cleaning, 2=damaged
   CALL sp_ReturnPackaging(1, 1, 8, 0, 40000.00, 1, @message);
   SELECT @message;

9. XỬ LÝ BAO BÌ SAU VỆ SINH:
   CALL sp_ProcessCleanedPackaging(1, 5, 1, 1, @message);
   SELECT @message;

10. TÍNH ĐIỂM THƯỞNG KHÁCH HÀNG:
    CALL sp_CalculateCustomerPoints(1, 500000.00, @points, @message);
    SELECT @points, @message;

11. CẬP NHẬT HẠNG KHÁCH HÀNG:
    CALL sp_UpdateCustomerRank(1, @message);
    SELECT @message;

=======================================================
GHI CHÚ:
- Tất cả procedures đã được test trên MariaDB 10.x
- Đảm bảo các bảng liên quan đã được tạo trước khi chạy
- Các trigger liên quan cần được tạo riêng
=======================================================
*/