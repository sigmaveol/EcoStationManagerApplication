-- =====================================================
-- ECOSTATION MANAGER - TRIGGERS & STORED PROCEDURES
-- Tự động hóa các tác vụ quản lý Refill Station
-- Dựa trên EcoStationManager_V0.sql và migrations
-- =====================================================

USE ecostationmanager;

DELIMITER $$

-- =====================================================
-- TRIGGERS - TỰ ĐỘNG HÓA BUSINESS LOGIC
-- =====================================================

-- 1. Tự động tính tổng tiền đơn hàng khi OrderDetails thay đổi
DROP TRIGGER IF EXISTS trg_OrderDetails_AfterInsert$$
CREATE TRIGGER trg_OrderDetails_AfterInsert
AFTER INSERT ON orderdetails
FOR EACH ROW
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(quantity * unit_price), 0)
        FROM orderdetails
        WHERE order_id = NEW.order_id
    ),
    last_updated = NOW()
    WHERE order_id = NEW.order_id;
END$$

DROP TRIGGER IF EXISTS trg_OrderDetails_AfterUpdate$$
CREATE TRIGGER trg_OrderDetails_AfterUpdate
AFTER UPDATE ON orderdetails
FOR EACH ROW
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(quantity * unit_price), 0)
        FROM orderdetails
        WHERE order_id = NEW.order_id
    ),
    last_updated = NOW()
    WHERE order_id = NEW.order_id;
END$$

DROP TRIGGER IF EXISTS trg_OrderDetails_AfterDelete$$
CREATE TRIGGER trg_OrderDetails_AfterDelete
AFTER DELETE ON orderdetails
FOR EACH ROW
BEGIN
    UPDATE orders
    SET total_amount = (
        SELECT COALESCE(SUM(quantity * unit_price), 0)
        FROM orderdetails
        WHERE order_id = OLD.order_id
    ),
    last_updated = NOW()
    WHERE order_id = OLD.order_id;
END$$

-- 2. Tự động tạo order_code nếu null khi tạo đơn hàng
DROP TRIGGER IF EXISTS trg_Orders_BeforeInsert$$
CREATE TRIGGER trg_Orders_BeforeInsert
BEFORE INSERT ON orders
FOR EACH ROW
BEGIN
    DECLARE next_id INT;
    
    IF NEW.order_code IS NULL OR NEW.order_code = '' THEN
        -- Sử dụng cách an toàn hơn để tạo mã
        SELECT COALESCE(MAX(order_id), 0) + 1 INTO next_id FROM orders;
        SET NEW.order_code = CONCAT('ORD-', LPAD(next_id, 5, '0'));
    END IF;
END$$

-- 3. Tự động cập nhật tồn kho khi StockIn
DROP TRIGGER IF EXISTS trg_StockIn_AfterInsert$$
CREATE TRIGGER trg_StockIn_AfterInsert
AFTER INSERT ON stockin
FOR EACH ROW
BEGIN
    DECLARE existing_inventory_id INT;
    
    IF NEW.ref_type = 0 THEN -- PRODUCT
        -- Tìm inventory_id nếu đã tồn tại batch_no
        SELECT inventory_id INTO existing_inventory_id
        FROM inventories 
        WHERE batch_no = NEW.batch_no AND product_id = NEW.ref_id
        LIMIT 1;
        
        IF existing_inventory_id IS NOT NULL THEN
            -- Cập nhật số lượng nếu đã tồn tại
            UPDATE inventories
            SET quantity = quantity + NEW.quantity,
                last_updated = NOW()
            WHERE inventory_id = existing_inventory_id;
        ELSE
            -- Thêm mới nếu chưa tồn tại
            INSERT INTO inventories (batch_no, product_id, quantity, expiry_date)
            VALUES (NEW.batch_no, NEW.ref_id, NEW.quantity, NEW.expiry_date);
        END IF;
    END IF;
END$$

-- 4. Tự động cập nhật tồn kho khi StockOut
DROP TRIGGER IF EXISTS trg_StockOut_AfterInsert$$
CREATE TRIGGER trg_StockOut_AfterInsert
AFTER INSERT ON stockout
FOR EACH ROW
BEGIN
    DECLARE v_remaining DECIMAL(10,2);
    DECLARE v_inv_id INT;
    DECLARE v_inv_qty DECIMAL(10,2);
    DECLARE v_deduct DECIMAL(10,2);
    DECLARE done INT DEFAULT FALSE;
    DECLARE cur CURSOR FOR 
        SELECT inventory_id, quantity 
        FROM inventories 
        WHERE product_id = NEW.ref_id AND quantity > 0
        ORDER BY expiry_date ASC, last_updated ASC;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    IF NEW.ref_type = 0 THEN -- PRODUCT
        SET v_remaining = NEW.quantity;
        
        OPEN cur;
        read_loop: LOOP
            FETCH cur INTO v_inv_id, v_inv_qty;
            IF done OR v_remaining <= 0 THEN
                LEAVE read_loop;
            END IF;
            
            SET v_deduct = LEAST(v_inv_qty, v_remaining);
            
            UPDATE inventories
            SET quantity = quantity - v_deduct,
                last_updated = NOW()
            WHERE inventory_id = v_inv_id;
            
            SET v_remaining = v_remaining - v_deduct;
        END LOOP;
        CLOSE cur;
    END IF;
END$$
    
-- 5. Tự động cập nhật PackagingInventories khi PackagingTransactions
DROP TRIGGER IF EXISTS trg_PackagingTransactions_AfterInsert$$
CREATE TRIGGER trg_PackagingTransactions_AfterInsert
AFTER INSERT ON packagingtransactions
FOR EACH ROW
BEGIN
    DECLARE v_exists INT DEFAULT 0;
    
    -- Kiểm tra xem PackagingInventories đã tồn tại chưa
    SELECT COUNT(*) INTO v_exists
    FROM packaginginventories
    WHERE packaging_id = NEW.packaging_id;
    
    IF v_exists = 0 THEN
        -- Tạo mới nếu chưa có
        INSERT INTO packaginginventories (packaging_id, qty_new, qty_in_use, qty_returned, qty_need_cleaning, qty_cleaned, qty_damaged)
        VALUES (NEW.packaging_id, 0, 0, 0, 0, 0, 0);
    END IF;
    
    IF NEW.type = 0 THEN -- ISSUE
        -- Cập nhật: giảm qty_new, tăng qty_in_use
        UPDATE packaginginventories
        SET qty_new = GREATEST(0, qty_new - NEW.quantity),
            qty_in_use = qty_in_use + NEW.quantity,
            last_updated = NOW()
        WHERE packaging_id = NEW.packaging_id;
    ELSEIF NEW.type = 1 THEN -- RETURN
        -- Thu hồi bao bì: giảm qty_in_use, tăng qty_returned
        UPDATE packaginginventories
        SET qty_in_use = GREATEST(0, qty_in_use - NEW.quantity),
            qty_returned = qty_returned + NEW.quantity,
            last_updated = NOW()
        WHERE packaging_id = NEW.packaging_id;
    END IF;
END$$

-- 6. Tự động cập nhật cleaned_datetime khi CleaningSchedule status = COMPLETED
DROP TRIGGER IF EXISTS trg_CleaningSchedules_BeforeUpdate$$
CREATE TRIGGER trg_CleaningSchedules_BeforeUpdate
BEFORE UPDATE ON cleaningschedules
FOR EACH ROW
BEGIN
    -- Nếu status chuyển sang COMPLETED (1) và cleaned_datetime chưa có
    IF NEW.status = 1 AND (OLD.status != 1) AND NEW.cleaned_datetime IS NULL THEN
        SET NEW.cleaned_datetime = NOW();
    END IF;
    
    -- Nếu status không phải COMPLETED thì xóa cleaned_datetime
    IF NEW.status != 1 THEN
        SET NEW.cleaned_datetime = NULL;
    END IF;
END$$

-- 7. Tự động tính điểm khách hàng khi đơn hàng hoàn thành
DROP TRIGGER IF EXISTS trg_Orders_AfterUpdate$$
CREATE TRIGGER trg_Orders_AfterUpdate
AFTER UPDATE ON orders
FOR EACH ROW
BEGIN
    -- Khi đơn hàng chuyển sang COMPLETED (5) và payment_status = PAID (1)
    IF NEW.status = 5 AND NEW.payment_status = 1 
       AND (OLD.status != 5 OR OLD.payment_status != 1)
       AND NEW.customer_id IS NOT NULL THEN
        
        -- Tính điểm và cập nhật
        CALL sp_CalculateCustomerPoints(
            NEW.customer_id,
            NEW.total_amount - COALESCE(NEW.discounted_amount, 0),
            @points_earned,
            @msg
        );
    END IF;
END$$

-- 8. Tự động cập nhật last_updated khi có thay đổi trong Orders
DROP TRIGGER IF EXISTS trg_Orders_BeforeUpdate$$
CREATE TRIGGER trg_Orders_BeforeUpdate
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
    SET NEW.last_updated = NOW();
END$$

-- 9. Tự động tạo customer_code nếu null
DROP TRIGGER IF EXISTS trg_Customers_BeforeInsert$$
CREATE TRIGGER trg_Customers_BeforeInsert
BEFORE INSERT ON customers
FOR EACH ROW
BEGIN
    DECLARE next_id INT;
    
    IF NEW.customer_code IS NULL OR NEW.customer_code = '' THEN
        -- Sử dụng cách an toàn hơn để tạo mã
        SELECT COALESCE(MAX(customer_id), 0) + 1 INTO next_id FROM customers;
        SET NEW.customer_code = CONCAT('CUS-', LPAD(next_id, 5, '0'));
    END IF;
END$$

-- 10. Tự động cập nhật rank khách hàng khi total_point thay đổi
DROP TRIGGER IF EXISTS trg_Customers_AfterUpdate$$
CREATE TRIGGER trg_Customers_AfterUpdate
AFTER UPDATE ON customers
FOR EACH ROW
BEGIN
    IF NEW.total_point != OLD.total_point THEN
        CALL sp_UpdateCustomerRank(NEW.customer_id, @rank_msg);
    END IF;
END$$

/*
TRIGGERS TỰ ĐỘNG:
1. trg_OrderDetails_AfterInsert/Update/Delete: Tự động tính tổng tiền đơn hàng
2. trg_Orders_BeforeInsert: Tự động tạo order_code nếu null
3. trg_StockIn_AfterInsert: Tự động cập nhật tồn kho khi nhập
4. trg_StockOut_AfterInsert: Tự động trừ tồn kho khi xuất (FIFO)
5. trg_PackagingTransactions_AfterInsert: Tự động cập nhật PackagingInventories
6. trg_CleaningSchedules_BeforeUpdate: Tự động set cleaned_datetime khi COMPLETED
7. trg_Orders_AfterUpdate: Tự động tính điểm khách hàng khi đơn hoàn thành
8. trg_Customers_BeforeInsert: Tự động tạo customer_code
9. trg_Customers_AfterUpdate: Tự động cập nhật rank khi điểm thay đổi
*/  